$\quad\;\:$BigARTM --- это кроссплатформенная (Windows и Linux) библиотека, реализующая концепцию аддитивной регуляризации. Библиотека ориентированна на обработку больших данных, поэтому 

\begin{enumerate}
	\item используемый в ней PLSA является пакетным и онлайновым;
	\item она поддерживает распараллеливание, как межпроцессорное, так и кластерное.
\end{enumerate}

Некоторые идеи, использованные при создании BigARTM были позаимствованы из ранних работ по схожей тематике~(\cite{smola}, \cite{ad_lda}).

Далее будут рассмотрены общие особенности строения и использования библиотеки.

\subsection{Пользовательский API}

$\quad\;\:$Основным классом библиотеки является \verb'Instance'. Объектов этого класса может быть несколько. В случае кластерного параллелизма они могут работать совместно, во всех остальных случаях работа каждого \verb'Instance' автономна. Данный объект нкапсулирует в себе три ключевые сущности --- списки \verb'DataLoader', \verb'Model' и \verb'Regularizer'. Число объектов этих классов в одном \verb'Instance' может быть произвольным. Это, в частности, означает, что имеется возможность одновременного обучения сразу нескольких тематических моделей с разными требованиями. 

Класс \verb'DataLoader' отвечает за загрузку документов. Поскольку библиотека является онлайновой, данные считываются из файлов типа \verb'.batch' потоком. Тем не менее, в библиотеке предусмотрена возможность единовременной загрузки данных с диска (после чего эти данные преобразуются в \verb'.batch' файлы, которые при следующем запуске можно использовать для ускорения работы). 

Класс \verb'Model' представляет собой собственно тематическую модель, обучаемую библиотекой. Как уже было сказано, экземпляр \verb'Instance' может содержать любое число моделей и одноверменно производить их обучение (в т.ч. и по разным коллекциям данных). Каждая модель имеет имя (строка). Сделано это для наглядности работы.

\verb'Regularizer' --- это объект-регуляризатор. Каждый \verb'Instance' хранит в себе список регуляризаторов, идентифицируемых, как и модели, по именам, а каждый экземпляр \verb'Model' содержит в себе список имён регуляризаторов из числа тех, что хранятся в \verb'Instance'.  По этому списку определяется необходимость применения того или иного регуляризатора к данной модели.

Рассмотрим теперь общую схему работы с интерфейсами.

Библиотека предоставляет пользователю интерфейсы на C++ и Python. В силу популярности и удобства Python для решения исследовательских задач, все программные выкладки будут приводится именно на нём. Это несущественно, поскольку API на C++, по своей структуре, абсолютно идентичен, с точностью до особенностей языка и интерфейса protocol buffers. 

\paragraph{Google Protocol buffers}
\footnote{Подробнее о Google Protocol Buffers можно прочесть в \cite{protobuf}}
Рассмотрим кратко эту технологию, поскольку в BigARTM она используется очень интенсивно. Protocol Buffers позволяет описывать proto-сообщения на псевдоязыке, которые затем можно преобразовать специальным компилятором (protoc) в структуры данных со всеми необходимыми методами на С++, Python и Java. Ключевой особенностью является возможность обмена сообщениями между этими языками программирования посредством механизма serializer/deserializer, переводящего сообщения в байт-массив и обратно. Данное решение является максимально переносимым и унифицированным.

Все конфигурации библиотеки, такие как настройки тематической модели, параметры регуляризаторов и т.п., определяются и передаются только посредством protobuf-сообщений. Результирующая модель также описывается соответствующим сообщением. Файл с сообщениями библиотеки назывется \verb'messages.proto', соответствующий файл на python будет называться \verb'messages_pb2.py'

Базовая схема работы с API BigARTM, исходя из всего вышеописанного, определяется следующей последовательностью действий:

\begin{enumerate}
	\item Описание конфигурации для объекта класса \verb'Instance'. Соответствующее protobuf-сообщение имеет вид:
	
	\vspace{5pt}
	\verb|message InstanceConfig {| \\
	\verb|optional int32 processors_count = 1 [default = 1];| \\
	\verb|optional string memcached_endpoint = 2;| \\
	\verb|optional int32 merger_queue_max_size = 3 [default = 10];| \\
	\verb|}|
	
	Все переменные являются опциональными (т.е. необязательными). Первый параметр отвечает за число процессоров при параллелизме (см. ниже), второй --- аргумент при использовании сервиса memcached (см. ниже), третий --- технический параметр внутренней компоненты ядра \verb'Merger', отвечающей за многопоточную обработку данных и корректное слияние результатов. В самом простом случае достаточно описать только первый параметр:
	
	\vspace{5pt}
	\verb|instance_config = messages_pb2.InstanceConfig()| \\
	\verb|instance_config.processors_count = processors_count|
		
	\item Создание экземпляра класса \verb'Instance': 
	
	\vspace{5pt}
	\verb|instance = library.CreateInstance(instance_config)|
	
	Здесь \verb'library' --- это динамическая библиотека, представляющая собой ядро BigARTM (\verb'artm.dll').
	
	\item В \verb'Instance' должен быть хотя бы один \verb'DataLoader'. В базовой конфигурации достаточно задать ему один параметр, после чего объект можно создать:
	
	\vspace{5pt}
	\verb|data_loader_config = messages_pb2.DataLoaderConfig()| \\
	\verb|data_loader_config.disk_path = DISK_PATH  #string| \\
	\verb|data_loader = library.CreateDataLoader(instance, data_loader_config)|
	
	\item Последняя подготовительная операция --- требуется добавить хотя бы одну тематическую модель. Для начала создадим набор её настроек. Большинство параметров конфигурации являются опциональными и имеют значения по-умолчанию. Остановимся здесь на настраивании тех из них, что наиболее сильно влияют на процесс обучения:

	\vspace{5pt}	

	создание объекта конфигурации:

	\verb|model_config = messages_pb2.ModelConfig()| \\
	
	задание имени модели:
	
	\verb|model_config.model_id = MODEL_NAME  #string| \\
	
	задание числа тем, которые нужно выделить:
	
	\verb|model_config.topics_count = topics_count| \\

	определение модели как <<активную>> (в противном случае модель не будет считаться до тех пор, пока не будет активизирована):

	\verb|model_config.enabled = true| \\
	
	задание числа итераций при просмотре одного документа:	
	
	\verb|model_config.inner_iterations_count = inner_iterations_count| \\
	
	добавление функционала качества, назначение его типа (0 соответствует перплексии):	
	
	\verb|score_ = model_config.score.add()| \\
	\verb|score_.type = 0|
	
	Модель готова к использованию. В ней нет регуляризаторов, о том, как их добавлять в \verb'Model' и \verb'Instance', подробно написано в соответствующем разделе.
	
	\item Для начала обучения модели(-ей) достаточно запустить цикл по числу проходов по коллекции, внутри которого должны быть следующие строчки: 
	
	\vspace{5pt}	
	
	производится вызов одного прохода по коллекции, ожидаем его завершения:	
	
	\verb|data_loader.InvokeIteration(1)| \\	
	\verb|data_loader.WaitIdle();| \\
    
    получаем итоговую (в рамках итерации) тематическую модель, представляющую собой матрицу $\Phi$, извлечь содержимое которой можно с помощью соответствующих методов (их, как и сам набор полей, можно посмотреть \verb'messages.py').
	
	\verb|topic_model = instance.GetTopicModel(model)|
	    
	В этом же цикле могут извлекаться и использоваться текущая информация о тематической модели, переконфигурироваться \verb'Model', добавляться/удаляться/изменяться регуляризаторы и т.п.
\end{enumerate}

Общая рекомендация при написании собственного кода --- изучить файл \verb'messages.proto' и его скомпилированную для нужного языка версию, файлы пользовательских API (\verb'cpp_interface.cc', \verb'python_interface.py'), а также \verb'cpp_client.cc' и \verb'python_client.py', которые представляют собой содержательные примеры пользовательского приложения, описанного над BigARTM.

{\bf Замечание:} На данный момент основным функционалом качества BigARTM является перплексия, рассчитываемая на каждой итерации прохода по коллекции.

\paragraph{Представление документов} В библиотеке реализована гибкая концепция представления данных. Каждый документ представляет собой экземпляр класса \verb'Item', который, помимо самого документа (хранимого в виде последовательности терминов), может содержать произвольные метаданные, связанные с ним. К таким данным относятся информация об авторе, дате публикации, ссылках на документ и из него, тегах и т.п. Всё это может оказаться крайне полезным при использовании тех или иных регуляризаторов.

\subsection{Сервис memcached}
\marginpar{\bf ToDo}

\subsection{Особенности распараллеливания}

$\quad\;\:$Многоядерный параллелизм работы алгоритмов <<вшит>> в библиотеку. От пользователя библиотеки требуется указать только один параметр --- \verb'processors_count', который входит в состав конфигурационного protobuf-сообщения для \verb'Instance'.

Кластерное распараллеливание устроено несколько сложнее.
\marginpar{\bf ToDo}
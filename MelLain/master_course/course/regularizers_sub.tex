
$\quad\;\:$Ключевым отличием BigARTM от других библиотек алгоритмов тематического моделирования является наличие регуляризаторов. Задача данного раздела --- описать API, предоставленный библиотекой для работы с существующими реализациями регуляризаторов, а также пояснить схему добавления новых.

\subsection{Краткое описание механизма регуляризации в BigARTM}
$\quad\;\:$Поскольку части матрицы $\Theta$ вычисляются независимо на разных процессорах, регуляризация $\Theta$ производится в каждом процессоре на всех енних итерациях. Объектом регуляризации является столбец матрицы (т.е. документ). Управлять процессом регуляризации $\Theta$ можно только между внешними итерациями. С матрицей $\Phi$ ситуация иная. Регуляризация происходит в \verb|Merger|, после того, как все процессоры на данной внешней итерации отработали, и новая матрица $\Phi$ сформирована. Регуляризация в логическом смысле опять работает со столбцом (т.е. с темой), но технически регуляризаторы вызываются для каждого элемента матрицы. При этом нормировочная константа, необходимая для выполнения М-шага \ref{learning} алгоритма, автоматически поправляется. $\Phi$ регуляризуется только на тех внешних итерациях, на которых это указал пользователь вызовом соответствующей функции (см. ниже). 

\subsection{Существующие регуляризаторы}

\subsubsection{Регуляризатор Дирихле}

$\quad\;\:$Рассмотрим популярную на сегодняшний день модель обучения LDA (latent Dirichlet allocation). Она основана на разложении \ref{eq_generic} при дополнительном предположении, что векторы документов $\theta_d = (\theta_{td} \in {\bf R}^{|T|})$ и векторы тем $\phi_t = (\phi_{wt} \in {\bf R}^{|W|})$ порождаются распределениями Дирихле с параметрами $\alpha \in {\bf R}^{|T|}$ и $\beta \in {\bf R}^{|W|}$ соответственно. В работе \cite{voron_potap_14} показано, что отличие LDA от PLSA --- в сглаживании $\phi_{wt}$ и $\theta_{td}$:

\begin{equation}
	\phi_{wt} = \cfrac{\hat n_{wt} + \beta_w}{\hat n_t + \sum_w \beta_w}, \quad 
 	\theta_{td} = \cfrac{\hat n_{td} + \alpha_t}{\hat n_d + \sum_t \alpha_t}, \quad
\end{equation}

Т.е. LDA --- это PLSA со встроенным регуляризатором сглаживания (здесь и далее --- регуляризатор Дирихле). Сглаживание может быть полезным для некоторых столбцов матриц, но в общем случае оно противоречит тому, что матрицы $\Phi$ и $\Theta$ должны быть сильно разреженными. 

\subsubsection{Регуляризатор сглаживания/разреживания}\label{smooth_sparse}
\footnote{Подробное описание и лингвистические обоснования этого регуляризатора можно найти в \cite{voron_potap_14}}

 Данный регуляризатор представляет собой модификацию сглаживающего регуляризатора Дирихле. Несмотря на простоту, уже данный регуляризатор решает задачи более сложные, чем регуляризатор Дирихле.

Разделим множество тем $T$ на предметные $S$ и фоновые $B$. Зададим вектор-столбцы параметров таким образом, чтобы в обеих матрицах $\Phi$ и $\Theta$ темы из $S$ одинаково разреживались, а темы из $B$ --- сглаживались каждая собственным образом. Это приводит к тому, что 

\begin{itemize}
	\item каждая тема из $S$ приобретает некоторое выраженное ядро терминов, отличающее её от остальных тем;
	\item каждая фоновая тема из $B$ сглаживается, причём вариация параметров приводит к тому, что разные темы выполняют различные задачи (выделение стоп-слов, общей лексики коллекции и т.п.).
\end{itemize}  

\subsection{Реализованные в BigARTM регуляризаторы}

$\quad\;\:$Все регуляризаторы описываются своими proto-сообщениями, содержащими необходимые данные и параметры. Конфигурационное сообщение для регуляризатора матрицы $\Theta$ должно содержать по одному набору параметров для каждой внутренней итерации. Сообщение для регуляризатора матрицы $\Phi$ наполняется одним набором параметров для одной внешней итерации. По истечении внешней итерации все конфигурации могут быть обновлены.

\subsubsection{Механизм словарей} 
$\quad\;\:$В качестве параметра регуляризатора могут использоваться т.н. словари --- структура данных, proto-сообщение для которых имеет следующий вид:

\vspace{4pt}
\noindent
\verb|message DictionaryConfig {| \\
\verb|  required string name = 1;| \\
\verb|  repeated DictionaryEntry entry = 2;| \\
\verb|}| \\
\noindent
\verb|message DictionaryEntry {| \\
\verb|  required string key_token = 1;| \\
\verb|  optional float value = 2;| \\
\verb|  repeated string value_tokens = 3;| \\
\verb|  optional FloatArray values = 4;| \\
\verb|}|

\vspace{4pt}

Первое поле сообщения \verb|DictionaryConfig| --- название словаря, второе --- список содержимого. Каждый элемент словаря (\verb|DictionaryEntry|) имеет четыре поля. \verb|key_token| --- собственно слово, \verb|value| --- какое-то числовое значение, соответствующее этому слову (например, частота встречаемости данного слова в коллекции). \verb|value_tokens| --- это некие термины, которые соответствуют данному слову (это могут быть переводы данного слова на другой язык и т.п.). Последнее поле --- это набор чисел, который может использоваться для хранения значений, необходимых для использования данного словаря. Словари являются крайне гибким способом задания параметров регуляризатора, поскольку могут содержать в себе самую разнообразную информацию. 

Механизм устроен следующим образом. Словари, используемые в определённых регуляризаторах, должны иметь нужную структуру (назначения полей в \verb|DictionaryEntry|), которая документируется на этапе написания регуляризатора его авторами. Для того, чтобы использовать словари, необходимо создать конфигурацию (заполнить описанное выше сообщение данными нужного вида) --- 
это можно сделать как во время работы библиотеки, так и до с помощью сторонней программы. После создания
 \footnote{Подробно процесс создания будет рассмотрен в секции <<Подключение регуляризаторов>>.}
 сообщения, его необходимо передать \verb|MasterComponent|, который создаст объект словаря. Все словари хранятся в виде списка в \verb|MasterComponent|, ключом при поиске нужного словаря явлется его имя.
Регуляризаторы, которым для работы могут понадобиться словари, имеют в своём конфигурационном сообщении поле \verb|dictionary_name|, которое содержит имена необходимых словарей. При создании или реконфигурации регуляризатор получает указатели на нужные словари.

\subsubsection{Реализации регуляризаторов} 
$\quad\;\:$На данный момент в BigARTM реализовано по одному базовому регуляризатору для каждой из матриц $\Phi$ и $\Theta$, информация о которых приведена ниже:

\begin{tabular}[t]{|p{14em}|p{26em}|}
\hline
\vspace{2pt} \textbf{Имя регуляризатора} \vspace{4pt} &
\vspace{2pt} \textbf{protobuf-сообщение} \vspace{4pt} \\

\hline
\vspace{4pt}

Регуляризатор сглаживания/ разреживания для $\Theta$ & 
\vspace{4pt}

\verb|message SmoothSparseThetaConfig {|
\verb|  required int32 background_topics_count = 1|
\verb|  repeated DoubleArray alpha = 2;|

\verb|}|
\vspace{4pt}

\\
\hline
\vspace{4pt}

Регуляризатор сглаживания/ разреживания для $\Phi$ &
\vspace{4pt}

\verb|message SmoothSparsePhiConfig {|
\verb|  required int32 background_topics_count = 1;|
\verb|  optional string dictionary_name = 2;|

\verb|}|
\vspace{4pt}

\\
\hline
\end{tabular}

\vspace{10pt}

{\bf Замечание:} В данной реализации регуляризатора фоновыми считаются $|B|$ тем с конца.

Для регуляризатора $\Theta$ каждый набор параметров состоит из вектора длиной в число тем (\verb|alpha|). Кроме того, имеется параметр числа фоновых тем \verb|background_topics_count|, который нужно указать. \verb|alpha| должен содержать отрицательные числа для тем из $S$, и положительные --- для тем из $B$.

Регуляризатор для $\Phi$ так же требует в явном виде указать число фоновых тем (поле \verb|background_topics_count|) --- это нужно для проверки корректности параметров. Во втором поле предполагается наличие имени словаря, который нужен этому регуляризатору. Поле \verb|value| в данном словаре --- это компонента вектора $\beta$, последние два поля для работы не нужны и могут оставаться пустыми. Встречая в документе термин, регуляризатор будет обращаться к словарю за значением поля \verb|value| для этого термина. Если термина в словаре нет, либо поле \verb|value| для него не определено, то регуляризация для данного слова производится не будет. В противном случае полученный элемент будет использоваться описанным в \ref{smooth_sparse} способом.

{\bf Замечание:} Выгода от использования словарей очевидна --- в ситуации, когда используется несколько регуляризаторов, которым требуется один и тот же набор данных, достаточно содать один словарь. Он будет использоваться всеми заинтересованными регудяризаторами и храниться в памяти в одном экземпляре. Кроме того, использование статических векторов $\beta$ (т.е. способа хранения, используемого в конфигурации \verb|SmoothSparseTheta|) приводит к зависимости регуляризатора от номеров терминов, который, вообще говоря, меняется при добавлении/удалении слов в коллекции. Словари же дают возможность непосредственной работы с терминами. Кроме того, механизм словарей --- крайне удобный инструмент при реализации мультиязычных регуляризаторов.

{\bf Замечание:} Регуляризатор сглаживания/разреживания превращается в регуляризатор Дирихле очевидным образом: достаточно задать нужным образом все элементы \verb|alpha| для $\Theta$ и словарь для $\Phi$ и присвоить ноль переменным \verb|background_topics_count|.

\paragraph{Значения параметров по-умолчанию.}\label{note}
 В случае, если вектор параметров $\alpha$ для регуляризатора $\Theta$ не указан, либо отсутствует имя словаря для регуляризатора $\Phi$, по-умолчанию используются единичные значения. Сделано это, в первую очередь, для удобства --- если все значения будут одинаковыми, достаточно регулировать их соответствующим коэффициентом регуляризации $\tau$ (\ref{reg_label}). Следует обратить внимание на то, что в случае, когда число наборов параметров $\alpha$ меньше, чем число внутренних итераций, все имеющиеся $\alpha$ будут использованы на первых итерациях. На всех оставшихся будут использоваться единичные векторы. 

\subsection{Подключение регуляризаторов}

$\quad\;\:$Теперь, на примере \verb|SmoothSparseTheta| и \verb|SmoothSparsePhi|, будет рассмотрен поэтапно процесс включения регуляризатора в тематическую модель. Предполагается, что переменная \verb|topic_counts| содержит общее число тем, выделяемых данной моделью, а \verb|background_topics_count| --- число тем, объявленных фоновыми. В случае, когда описание будет одинаковым для регуляризаторов $\Phi$ и $\Theta$, будут показаны действия с \verb|SmoothSparseTheta|.

\begin{enumerate}
	\item Прежде всего следует создать конфигурационное сообщение для регуляризатора. Оно может быть описано так:
	
	\vspace{4pt}
        \verb|  regularizer_config_theta = messages_pb2.SmoothSparseThetaConfig()| \\
        \verb|  regularizer_config_theta.background_topics_count = | \\
        \verb|    background_topics_count| \\
        \verb|  for i in range(0, inner_iterations_count):| \\
        \verb|    alpha_ref = regularizer_config_theta.alpha.add()| \\
        \verb|    for j in range(0, topics_count - background_topics_count):| \\
        \verb|      alpha_ref.value.append(-0.5)| \\
        \verb|    for j in range(0, background_topics_count):| \\
        \verb|      alpha_ref.value.append(0.5)|
	\vspace{4pt}
	
	\vspace{4pt}
        \verb|  regularizer_config_phi = messages_pb2.SmoothSparsePhiConfig()| \\
        \verb|  regularizer_config_phi.background_topics_count = | \\
        \verb|    background_topics_count| \\
        \verb|  regularizer_config_phi.dictionary_name = 'phi_dictionary'|
	\vspace{4pt}	
	
	\item Для создания регуляризатора используется функция \verb|CreateRegularizer()|. Она имеет следующий вид:
	
	\vspace{4pt}	
	\verb|  MasterComponentObject.CreateRegularizer(name, type, config)|
	\vspace{4pt}	
	
	Здесь первое и второе поля --- имя и тип создаваемого регуляризатора соответственно. Имя --- это строка, тип --- число, определённое при создании регуляризатора (описанным выше регуляризаторам сглаживания/разреживания соответствуют типы 2 и 3). Третье поле --- это описанная выше конфигурация самого регулzризатора. В рассматриваемом примере вызов может быть таким:
	
	\vspace{4pt}	
	\verb|  regularizer_theta = master_component.CreateRegularizer(| \\
	\verb|    'regularizer_theta', 2, regularizer_config_theta)|
	\vspace{4pt}	
	
	Добавляемый регуляризатор сохранён в данном \verb|MasterComponent|, все модели, ассоциированные с этим \verb|MasterComponent|, могут использовать его.	
	
	Вспомним, что регуляризатору $\Phi$ для работы требуется словарь. Процесс получения этого словаря оставляется на усмотрение пользователя (пример описан в \verb|python_client.py|). Допустим, что конфигурационное сообщение \verb|dictionary_config| словаря получено (поле \verb|name = 'phi_dictionary'|). Создание словаря в $MasterComponent$ производится следующим образом:

	\vspace{4pt}
	\verb|  dictionary = master_component.CreateDictionary(dictionary_config)|
	\vspace{4pt}
	
	Теперь словарь хранится а \verb|master_component| и все регуляризаторы, в конфигурации которых указано название этого словаря, смогут его использовать.	
	
	\item Теперь требуется сообщить нужной тематической модели о том, что при её обучении должен использоваться \verb|regularizer_theta|. Для этого требуется модификации шага \ref{step_1} в алгоритме работы с библиотекой. Перед созданием модели её конфигурация дополняется ещё двумя строками:
	
	\vspace{4pt}	
	\verb|  model_config.regularizer_name.append('regularizer_theta')| \\
	\verb|  model_config.regularizer_tau.append(1)|
	\vspace{4pt}	
		
	Таким образом модель <<узнаёт>> имя регуляризатора, который нужно будет использовать, а также его коэффициент регуляризации. Разные модели могут иметь разные списки используемых регуляризаторов. При этом все эти регуляризаторы, как уже было отмечено, будут храниться в активном экземпляре \verb|MasterComponent|.
	
	\item Регуляризация $\Theta$ после добавления регуляризатора в модель будет производиться автоматически на каждой внутренней итерации. В случае, когда на данной внешней итерации нужно произвести регуляризацию $\Phi$, необходимо в шаге \ref{step_2} алгоритма использования библиотеки после строки
	
	\vspace{4pt}	
	\verb|  topic_model = master_component.GetTopicModel(model)|
	\vspace{4pt}	
	
	сразу вставить строку 
	
	\vspace{4pt}	
	\verb|  topic_model.InvokePhiRegularizers();|
	\vspace{4pt}		
	
	Если для регуляризации требуется обновить конфигурации регуляризаторов, делать это нужно между выгрузкой модели и вызовом \verb|InvokePhiRegularizers();|, поскольку текущие данные модели могут быть нужны для настройки параметров регуляризации. В случае, если данная внешняя итерация является последней, для учёта регуляризации требуется ещё раз выгрузить модель уже после вызова регуляризации и полученный результат считать финальным.
	
	Стоит обратить внимание на то, что при регуляризации будут вызваны все регуляризаторы матрицы $\Phi$, ассоциированные с данной моделью.
	
	\item Часто возникает потребность заменить параметры существующего регуляризатора. Для этого необходимо описать новое конфигурационное сообщение, после чего вызвать функцию перенастройки:
	
	\vspace{4pt}	
	\verb|  regularizer_theta.Reconfigure(new_regularizer_config_theta)|
	\vspace{4pt}
	
	Аналогичным образом заменяется соответствующий какому-либо регуляризатору параметр $\tau$, а также производится обновление словарей.
	
	\item Для удаления регуляризатора из модели достаточно удалить его имя из списка \verb|model_config.regularizer_name|, а также удалить коэффициент $\tau$ из списка \verb|model_config.regularizer_tau|, после чего реконфигурировать модель обновлённой \verb|model_config|. Сам \verb|regularizer_theta| будет удалён автоматически при завершении работы \verb|MasterComponent|.
	
\end{enumerate}

\subsection{Создание нового регуляризатора}
\footnote{Данный раздел не имеет отношения к пользовательской документации и предназначен для разработчиков BigARTM. Описанная в нём информация требует более глубокого понимания устройства библиотеки}

Далее описан процесс создания нового регуляризатора и добавления его в библиотеку. Данные действия подчиняются некоторым общим правилам, поэтому будут изложены в алгоритмическом виде:

\begin{enumerate}
	\item В первую очередь требуется описать в файле \verb'messages.proto' protobuf-сообщение ---  конфигурацию нового регуляризатора, после чего добавить соответствующий элемент в поле \verb'Type' в сообщении-оболочке \verb'RegularizerConfig'.
	
	\item Затем необходимо написать \verb'.h' и \verb'.cc' файлы создаваемого регуляризатора и добавить их в проект \verb'libartm'. В данном пункте следует учитывать несколько деталей, которые будут рассмотрены подробнее в конце данного раздела.
	
	\item После нужно добавить в файл \verb'c_interface.cc #include' с именем \verb'.h' файла нового регуляризатора.
	
	\item В  \verb'c_interface.cc' надо найти функцию \verb'ArtmReconfigureRegularizer()'. В ней есть switch по типам регуляризаторов, в который требуется добавить case с типом своего регуляризатора (для этого можно просто скопировать один из существующих case и поменять в нём имена регуляризатора и его конфигурации).
	
	\item Для того, чтобы использовать добавленный регуляризатор, осталось скомпилировать \verb'messages.proto' (используя компилятор \verb'protoc') в файлы на C++ и Python, после чего перекомпилировать проекты \verb'libartm' и \verb'artm'.
\end{enumerate}

\paragraph{Рекомендации по написанию файлов регуляризаторов.} Любой регуляризатор, описанный в библиотеке, должен удовлетворять нескольким требованиям:

\begin{itemize}
	\item Регуляризатор обязательно пишется (как и всё ядро библиотеки) на С++ (.cс и .h файлы).

	\item Регуляризатор представляет собой класс-наследник класса \verb'RegularizerInterface'. Данный класс содержит два виртуальных метода, которые нужно описывать
	
	\vspace{10pt}
	\verb|virtual bool RegularizeTheta(const Item& item, | \\
	\verb|                             std::vector<float>* n_dt,| \\
	\verb|                             int topic_size,| \\
	\verb|                             int inner_iter,| \\
	\verb|                             double tau)|
	
	\verb|virtual bool RegularizePhi(core::TopicModel* topic_model, | \\
	\verb|                           double tau)|
	\vspace{10pt}
	
	Как понятно из названия, каждый метод отвечает за регуляризацию соответствующей матрицы.
	
	\item Класс регуляризатора вместе со всем своим содержимым должен быть описан в namespace \verb'regularizer'.
	
	\item Технически допустима реализация в одном классе регуляризатора сразу для обеих матриц, однако рекомендуется этого избегать и описывать один (в математическом смысле) регуляризатор в двух разных классах и работать с ними как с разными объектами. Это существенно упростит конфигурацию отдельного регуляризатора, использование его данных в функциях регуляризации, а также избавит от необходимости задавать ненужные данные, когда потребуется регуляризация только одной матрицы.
	
	\item В случае, когда регуляризатору для работы требуются один или несколько словарей, необходимо учесть их количество и структуру, после чего зафиксировать и документировать эту информацию. Корректность работы регуляризатора будет гарантироваться только в случае, если подаваемые словари соответствуют предъявляемым требованиям.
	
	\item Файл \verb'.h' будет отличаться для разных регуляризаторов только названием, достаточно скопировать какой-нибудь существующий (регуляризирующий ту же матрицу) и поменять необходимые имена типов.
	
	\item Файл \verb'.cc' будет включать в себя реализацию соответствующего метода регуляризации. Сама реализация, в свою очередь, состоит из трёх концептуальных этапов --- считывания данных из объекта-конфигурации, проверки корректности этих данных и собственно регуляризации. Считывание данных рекомендуется производить в структуры тех же типов, что и используемые в конфигурации --- т.е. описанные в файлах \verb'messages.pb.h' и \verb'messages.pb.cc' protobuf-типы. Во время проверки корректности ввода следует возвращать из функции \verb'false' в случае выявления несоответствия. Наконец, после окончания этапа регуляризации следует вернуть \verb'true'. Кроме того, описываемый регуляризатор обязательно должен удовлетворять замечанию \ref{note}.
	
\end{itemize}

{\bf Замечание: } В целом, при написании нового регуляризатора рекомендуется опираться на существующие реализации, это может сэкономить немало времени.

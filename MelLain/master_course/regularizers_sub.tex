
$\quad\;\:$Ключевым отличием BigARTM от других библиотек алгоритмов тематического моделирования является наличие регуляризаторов. Задача данного раздела --- описать API, предоставленный библиотекой для работы с существующими реализациями регуляризаторов, а также пояснить схему добавления новых.

\subsection{Краткое описание механизма регуляризации в BigARTM}
$\quad\;\:$Поскольку части матрицы $\Theta$ вычисляются независимо на разных процессорах, регуляризация $\Theta$ производится в каждом процессоре на всех внутренних итерациях. Объектом регуляризации является столбец матрицы (т.е. документ). Управлять процессом регуляризации $\Theta$ можно только между внешними итерациями. С матрицей $\Phi$ ситуация иная. Регуляризация происходит в \verb|Merger|, после того, как все процессоры на данной внешней итерации отработали, и новая матрица $\Phi$ сформирована. Регуляризация в логическом смысле опять работает со столбцом (т.е. с темой), но технически регуляризаторы вызываются для каждого элемента матрицы. При этом нормировочная константа, необходимая для выполнения М-шага \ref{learning} алгоритма, автоматически поправляется. $\Phi$ регуляризуется только на тех внешних итерациях, на которых это указал пользователь вызовом соответствующей функции (см. ниже). 

\subsection{Существующие регуляризаторы}

\subsubsection{Регуляризатор Дирихле}

$\quad\;\:$Рассмотрим популярную на сегодняшний день модель обучения LDA (latent Dirichlet allocation). Она основана на разложении \ref{eq_generic} при дополнительном предположении, что векторы документов $\theta_d = (\theta_{td} \in {\bf R}^{|T|})$ и векторы тем $\phi_t = (\phi_{wt} \in {\bf R}^{|W|})$ порождаются распределениями Дирихле с параметрами $\alpha \in {\bf R}^{|T|}$ и $\beta \in {\bf R}^{|W|}$ соответственно. В работе \cite{voron_potap_14} показано, что отличие LDA от PLSA --- в сглаживании $\phi_{wt}$ и $\theta_{td}$:

\begin{equation}
	\phi_{wt} = \cfrac{\hat n_{wt} + \beta_w}{\hat n_t + \sum_w \beta_w}, \quad 
 	\theta_{td} = \cfrac{\hat n_{td} + \alpha_t}{\hat n_d + \sum_t \alpha_t}, \quad
\end{equation}

Т.е. LDA --- это PLSA со встроенным регуляризатором сглаживания (здесь и далее --- регуляризатор Дирихле). Сглаживание может быть полезным для некоторых столбцов матриц, но в общем случае оно противоречит тому, что матрицы $\Phi$ и $\Theta$ должны быть сильно разреженными. 

\subsubsection{Регуляризатор сглаживания/разреживания}
\footnote{Подробное описание и лингвистические обоснования этого регуляризатора можно найти в \cite{voron_potap_14}}

 Данный регуляризатор представляет собой модификацию сглаживающего регуляризатора Дирихле. Несмотря на простоту, уже данный регуляризатор решает задачи более сложные, чем регуляризатор Дирихле.

Разделим множество тем $T$ на предметные $S$ и фоновые $B$. Зададим вектор-столбцы параметров таким образом, чтобы в обеих матрицах $\Phi$ и $\Theta$ темы из $S$ одинаково разреживались, а темы из $B$ --- сглаживались каждая собственным образом. Это приводит к тому, что 

\begin{itemize}
	\item каждая тема из $S$ приобретает некоторое выраженное ядро терминов, отличающее её от остальных тем;
	\item каждая фоновая тема из $B$ сглаживается, причём вариация параметров приводит к тому, что разные темы выполняют различные задачи (выделение стоп-слов, общей лексики коллекции и т.п.).
\end{itemize}  

\subsection{Реализованные в BigARTM регуляризаторы}

$\quad\;\:$Все регуляризаторы описываются своими proto-сообщениями, содержащими необходимые данные и параметры. Конфигурационное сообщение для регуляризатора матрицы $\Theta$ должно содержать по одному набору параметров для каждой внутренней итерации. Сообщение для регуляризатора матрицы $\Phi$ наполняется одним набором параметров для одной внешней итерации. По истечении внешней итерации все конфигурации могут быть обновлены.

На данный момент в BigARTM реализовано по одному базовому регуляризатору для каждой из матриц $\Phi$ и $\Theta$, информация о которых приведена ниже:

\begin{tabular}[t]{|p{14em}|p{26em}|}
\hline
\vspace{2pt} \textbf{Имя регуляризатора} \vspace{4pt} &
\vspace{2pt} \textbf{protobuf-сообщение} \vspace{4pt} \\

\hline
\vspace{4pt}

Регуляризатор сглаживания/ разреживания для $\Theta$ & 
\vspace{4pt}

\verb|message SmoothSparseThetaConfig {|
\verb|  required int32 background_topics_count = 1|
\verb|  repeated DoubleArray alpha = 2;|

\verb|}|
\vspace{4pt}

\\
\hline
\vspace{4pt}

Регуляризатор сглаживания/ разреживания для $\Phi$ &
\vspace{4pt}

\verb|message SmoothSparsePhiConfig {|
\verb|  required int32 background_topics_count = 1;|
\verb|  optional DoubleArray beta = 2;|
\verb|  repeated DoubleArray background_beta = 3;|

\verb|}|
\vspace{4pt}

\\
\hline
\end{tabular}

\vspace{10pt}

{\bf Замечание:} В данной реализации регуляризатора фоновыми считаются $|B|$ тем с конца.

Для регуляризатора $\Theta$ каждый набор параметров состоит из вектора длиной в число тем (\verb|alpha|). Кроме того, имеется параметр числа фоновых тем \verb|background_topics_count|, который нужно указать. \verb|alpha| должен содержать отрицательные числа для тем из $S$, и положительные --- для тем из $B$.

Регуляризатор для $\Phi$ так же требует в явном виде указать число фоновых тем (поле \verb|background_topics_count|) --- это нужно для проверки корректности параметров. \verb'beta' --- вектор отрицательных чисел длиной с текущее число терминов в матрице $\Phi$, предназначенный для разреживания тем из $S$. \verb|background_beta| --- векторы положительных чисел, сглаживающие фоновые темы. Этих векторов --- по одному на каждую фоновую тему.

{\bf Замечание:} Регуляризатор сглаживания/разреживания превращается в регуляризатор Дирихле очевидным образом: достаточно задать все элементы \verb|alpha| и \verb|beta|, присвоить ноль переменным \verb|background_topics_count| и не затрагивать поле \verb|background_beta|.

\paragraph{Значения параметров по-умолчанию.}\label{note}
 В случае, если какой-то из векторов параметров $\alpha$ или $\beta$ не указан, по-умолчанию используется вектор из единиц соответствующей размерности. Сделано это, в первую очередь, для удобства --- если все значения будут одинаковыми, достаточно регулировать их соответствующим коэффициентом регуляризации $\tau$ (\ref{reg_label}). Следует обратить внимание на то, что в случае, когда число наборов параметров $\alpha$ меньше, чем число внутренних итераций, все имеющиеся $\alpha$ будут использованы на первых итерациях. На всех оставшихся будут использоваться единичные векторы.

\subsection{Подключение регуляризаторов}

$\quad\;\:$Теперь, на примере \verb|SmoothSparseTheta|, будет рассмотрен поэтапно процесс включения регуляризатора в тематическую модель. Предполагается, что переменная \verb|topic_counts| содержит общее число тем, выделяемых данной моделью, а \verb|background_topics_count| --- число тем, объявленных фоновыми.

\begin{enumerate}
	\item Прежде всего следует создать конфигурационное сообщение для регуляризатора. Оно может быть описано так:
	
	\vspace{4pt}
        \verb|  regularizer_config_theta = messages_pb2.SmoothSparseThetaConfig()| \\
        \verb|  for i in range(0, inner_iterations_count):| \\
        \verb|    alpha_ref = regularizer_config_theta.alpha.add()| \\
        \verb|    for j in range(0, topics_count - background_topics_count):| \\
        \verb|      alpha_ref.value.append(-0.5)| \\
        \verb|    for j in range(0, background_topics_count):| \\
        \verb|      alpha_ref.value.append(0.5)|
	\vspace{4pt}
	
	\item Для создания регуляризатора используется функция \verb|CreateRegularizer()|. Она имеет следующий вид:
	
	\vspace{4pt}	
	\verb|  MasterComponentObject.CreateRegularizer(name, type, config)|
	\vspace{4pt}	
	
	Здесь первое и второе поля --- имя и тип создаваемого регуляризатора соответственно. Имя --- это строка, тип --- число, определённое при создании регуляризатора (описанным выше регуляризаторам сглаживания/разреживания соответствуют типы 2 и 3). Третье поле --- это описанная выше конфигурация самого регулzризатора. В рассматриваемом примере вызов может быть таким:
	
	\vspace{4pt}	
	\verb|  regularizer_theta = master_component.CreateRegularizer(| \\
	\verb|    'regularizer_theta', 2, regularizer_config_theta)|
	\vspace{4pt}	
	
	Добавляемый регуляризатор сохранён в данном \verb|MasterComponent|, все модели, ассоциированные с этим \verb|MasterComponent|, могут использовать его.	
	
	\item Теперь требуется сообщить нужной тематической модели о том, что при её обучении должен использоваться \verb|regularizer_theta|. Для этого требуется модификации шага \ref{step_1} в алгоритме работы с библиотекой. Перед созданием модели её конфигурация дополняется ещё двумя строками:
	
	\vspace{4pt}	
	\verb|  model_config.regularizer_name.append('regularizer_theta')| \\
	\verb|  model_config.regularizer_tau.append(1)|
	\vspace{4pt}	
		
	Таким образом модель <<узнаёт>> имя регуляризатора, который нужно будет использовать, а также его коэффициент регуляризации. Разные модели могут иметь разные списки используемых регуляризаторов. При этом все эти регуляризаторы, как уже было отмечено, будут храниться в активном экземпляре \verb|MasterComponent|.
	
	\item В случае, когда на данной внешней итерации нужно произвести регуляризацию $\Phi$, необходимо в шаге \ref{step_2} алгоритма использования библиотеки после строки
	
	\vspace{4pt}	
	\verb|  topic_model = master_component.GetTopicModel(model)|
	\vspace{4pt}	
	
	сразу вставить строку 
	
	\vspace{4pt}	
	\verb|  topic_model.InvokePhiRegularizers();|
	\vspace{4pt}		
	
	Если для регуляризации требуется обновить конфигурации регуляризаторов, делать это нужно между выгрузкой модели и вызовом \verb|InvokePhiRegularizers();|, поскольку текущие данные модели могут быть нужны для настройки параметров регуляризации. В случае, если данная внешняя итерация является последней, для учёта регуляризации требуется ещё раз выгрузить модель уже после вызова регуляризации и полученный результат считать финальным.
	
	Стоит обратить внимание на то, что при регуляризации будут вызваны все регуляризаторы матрицы $\Phi$, ассоциированные с данной моделью.
	
	\item Часто возникает потребность заменить параметры существующего регуляризатора. Для этого необходимо описать новое конфигурационное сообщение, после чего вызвать функцию перенастройки:
	
	\vspace{4pt}	
	\verb|  regularizer_theta.Reconfigure(new_regularizer_config_theta)|
	\vspace{4pt}
	
	Аналогичным образом заменяется соответствующий какому-либо регуляризатору параметр $\tau$.
	
	\item Для удаления регуляризатора из модели достаточно удалить его имя из списка \verb|model_config.regularizer_name|, а также удалить коэффициент $\tau$ из списка \verb|model_config.regularizer_tau|, после чего реконфигурировать модель обновлённой \verb|model_config|. Сам \verb|regularizer_theta| будет удалён автоматически при завершении работы \verb|MasterComponent|.
	
\end{enumerate}

\subsection{Создание нового регуляризатора}
\footnote{Данный раздел не имеет отношения к пользовательской документации и предназначен для разработчиков BigARTM. Описанная в нём информация требует более глубокого понимания устройства библиотеки}

Далее описан процесс создания нового регуляризатора и добавления его в библиотеку. Данные действия подчиняются некоторым общим правилам, поэтому будут изложены в алгоритмическом виде:

\begin{enumerate}
	\item В первую очередь требуется описать в файле \verb'messages.proto' protobuf-сообщение ---  конфигурацию нового регуляризатора, после чего добавить соответствующий элемент в поле \verb'Type' в сообщении-оболочке \verb'RegularizerConfig'.
	
	\item Затем необходимо написать \verb'.h' и \verb'.cc' файлы создаваемого регуляризатора и добавить их в проект \verb'libartm'. В данном пункте следует учитывать несколько деталей, которые будут рассмотрены подробнее в конце данного раздела.
	
	\item После нужно добавить в файл \verb'c_interface.cc #include' с именем \verb'.h' файла нового регуляризатора.
	
	\item В  \verb'c_interface.cc' надо найти функцию \verb'ArtmReconfigureRegularizer()'. В ней есть switch по типам регуляризаторов, в который требуется добавить case с типом своего регуляризатора (для этого можно просто скопировать один из существующих case и поменять в нём имена регуляризатора и его конфигурации).
	
	\item Для того, чтобы использовать добавленный регуляризатор, осталось скомпилировать \verb'messages.proto' (используя компилятор \verb'protoc') в файлы на C++ и Python, после чего перекомпилировать проекты \verb'libartm' и \verb'artm'.
\end{enumerate}

\paragraph{Рекомендации по написанию файлов регуляризаторов.} Любой регуляризатор, описанный в библиотеке, должен удовлетворять нескольким требованиям:

\begin{itemize}
	\item Регуляризатор обязательно пишется (как и всё ядро библиотеки) на С++ (.cс и .h файлы).

	\item Регуляризатор представляет собой класс-наследник класса \verb'RegularizerInterface'. Данный класс содержит два метода
	
	\vspace{10pt}
	\verb|bool RegularizeTheta(const Item& item,| 
	
	\verb|    std::vector<float>* n_dt, int topic_size, int inner_iter)|
	
	\verb'bool RegularizePhi(TopicModel* topic_model)'
	\vspace{10pt}
	
	Как понятно из названия, каждый метод отвечает за регуляризацию соответствующей матрицы.
	
	\item Класс регуляризатора вместе со всем своим содержимым должен быть описан в namespace \verb'regularizer'.
	
	\item Технически допустима реализация в одном классе регуляризатора сразу для обеих матриц, однако рекомендуется этого избегать и описывать один (в математическом смысле) регуляризатор в двух разных классах и работать с ними как с разными объектами. Это существенно упростит конфигурацию отдельного регуляризатора, использование его данных в функциях регуляризации, а также избавит от необходимости задавать ненужные данные, когда потребуется регуляризация только одной матрицы.
	
	\item Файл \verb'.h' будет отличаться для разных регуляризаторов только названием, достаточно скопировать какой-нибудь существующий (регуляризирующий ту же матрицу) и поменять необходимые имена типов.
	
	\item Файл \verb'.cc' будет включать в себя реализацию соответствующего метода регуляризации. Сама реализация, в свою очередь, состоит из трёх концептуальных этапов --- считывания данных из объекта-конфигурации, проверки корректности этих данных и собственно регуляризации. Считывание данных рекомендуется производить в структуры тех же типов, что и используемые в конфигурации --- т.е. описанные в файлах \verb'messages.pb.h' и \verb'messages.pb.cc' protobuf-типы. Во время проверки корректности ввода следует возвращать из функции \verb'false' в случае выявления несоответствия. Наконец, после окончания этапа регуляризации следует вернуть \verb'true'. Кроме того, описываемый регуляризатор обязательно должен удовлетворять замечанию \ref{note}.
	
\end{itemize}

{\bf Замечание: } В целом, при написании нового регуляризатора рекомендуется опираться на существующие реализации, это может сэкономить немало времени.

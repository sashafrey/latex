
$\quad\;\:$Ключевым отличием BigARTM от других библиотек алгоритмов тематического моделирования является наличие регуляризаторов. Задача данного раздела --- описать API, предоставленный библиотекой для работы с существующими реализациями регуляризаторов, а также пояснить схему добавления новых.

\subsection{Пользовательский API}

$\quad\;\:$Как было описано ранее, для использования библиотеки требуется, в первую очередь, создать объект \verb'Instance', после чего добавить в него необходимые тематические модели, имеющие каждая свои конфигурации. Эти конфигурации, помимо всего прочего, содержат список имён регуляризаторов (подмножество списка, хранящегося в \verb'Instance').

Рассмотрим процесс добавления регуляризатора в \verb'Instance' и в конкретную модель по-подробнее.  Предположим, что в библиотеке уже описан регуляризатор типа \verb'MyRegularizer', который необходимо добавить в модель. Схема выполнения этой операции следующая:
\begin{enumerate}
	\item Открыть файл \verb'messages.proto', найти в нём protobuf-сообщение, соответствующее конфигурации регуляризатора типа \verb'MyRegularizer' (оно будет иметь имя \verb'MyRegularizerConfig').
	
	\item Используя язык, на котором описывается среда эксперимента, создать объект типа \verb'MyRegularizerConfig', заполнить необходимые поля теми параметрами регуляризатора, которые требуются. 
	
	\item Создать объект типа \verb'RegularizerConfig', который является обёрткой для регуляризатора любого типа. У этого объекта имеется три поля, которые требуется заполнить --- имя регуляризатора, его тип (найти тип, соответствующий \verb'MyRegularizer' можно в \verb'Type' в protobuf-сообщении, описывающем \verb'RegularizerConfig') и конфигурацию регуляризатора \verb'MyRegularizer'. Следует учесть, что это поле требует в качестве значения строку --- сериализованное сообщение \verb'MyRegularizerConfig', а не сам объект, созданный в п.2, поэтому его следует сериализовать, вызвав 
	
	\vspace{10pt}
	\verb'MyRegularizerConfig.SerializeToString()'.
	\vspace{10pt}
	
	\item Подготовив конфигурацию для \verb'MyRegularizer', добавим его в \verb'Instance', вызвав функцию
	
	\vspace{10pt}
	\verb|regularizer_object = CreateRegularizer(instance, regularizer_config_wrapper)| 
	\vspace{10pt}
	
	где \verb'instance' --- номер объекта \verb'Instance', а \verb'regularizer_config_wrapper' --- объект-обёртка типа \verb'RegularizerConfig'.
	
	\item После того, как регуляризатор был создан, а его имя было добавлено в список существующих для данного \verb'Instance' регуляризаторов, требуется указать имя этого регуляризатора в соответствующих списках тех моделей, к которым его нужно применять. Для этого нужно добавить в сообщение-конфигурацию модели, в поле \verb'regularizer_name', новый элемент, соответствующий имени регуляризатора. После требуется обновить конфигурацию модели.
	
	\item В случае, когда требуется заменить конфигурацию существующего объекта регуляризатора, необходимо модифицировать соответствующим образом объект-конфигурацию, после чего вызвать функцию 
	
	\vspace{10pt}
	\verb|regularizer_object.Reconfigure(regularizer_config_wrapper)| 
	\vspace{10pt}
	
	\item Удаление регуляризатора из модели производится по тому же принципу, что и добавление --- необходимо удалить имя этого регуляризатора из соответствующего списка в параметрах модели и реконфигурировать её. Удаление объекта регуляризатора из \verb'Instance' произойдёт при вызове \verb'__exit__()' (в C++ --- при вызове деструктора).
			
\end{enumerate}

Регуляризаторы матрицы $\Theta$, будучи добавленными в модель, будут вызываться автоматически при работе алгоритма. Вызов регуляризаторов $\Phi$ производится пользователем (например, после одного прохода по коллекции), для этого используется функция

	\vspace{10pt}
	\verb|model.InvokePhiRegularizers()| 
	\vspace{10pt}
	
\noindent где \verb'model' --- модель, для которой производится регуляризация матрица $\Phi$.

Регуляризаторы для матрицы Phi имеют один набор параметров для каждой внешней итерации (прохода по коллекции), менять этот набор, соотвественно, можно по завершении текущей итерации. Для регуляризаторов матрицы $\Theta$ также можно задавать новый набор параметров каждую внешнюю итерацию. Однако следует помнить, что регуляризаторы этой матрицы могут требовать разные параметры на этапе внутренней итерации (прохода по документу), и редактировать эти параметры во время внешней итерации нельзя. Поскольку число внутренних итераций задаётся до начала работы алгоритма, предполагается, что конфигурация регуляризатора для $\Theta$ будет содержать по одному набору параметров для каждой внутренней итерации до начала соответствующей внешней.

\subsection{Создание нового регуляризатора}

$\quad\;\:$Опишем процесс создания нового регуляризатора и добавления его в библиотеку. Данные действия подчиняются некоторым общим правилам, поэтому изложим их в виде последовательности шагов:

\begin{enumerate}
	\item В первую очередь требуется описать в файле \verb'messages.proto' protobuf-сообщение ---  конфигурацию нового регуляризатора, после чего добавить соответствующий элемент в поле \verb'Type' в общем сообщении \verb'RegularizerConfig'.
	
	\item Затем необходимо написать \verb'.h' и \verb'.cc' файлы создаваемого регуляризатора и добавить их в проект \verb'libartm'. В данном пункте следует учитывать несколько деталей, на которых остановимся подробнее в конце этого подраздела.
	
	\item После добавить в файл \verb'c_interface.cc #include' с именем \verb'.h' файла нового регуляризатора.
	
	\item В  \verb'c_interface.cc' нужно найти функцию \verb'ArtmReconfigureRegularizer()'. В ней есть switch по типам регуляризаторов, в который требуется добавить case с типом своего регуляризатора (для этого можно просто скопировать один из существующих существующий case и поменять в нём имена регуляризатора и его конфигурации).
	
	\item Для того, чтобы использовать добавленный регуляризатор, осталось скомпилировать \verb'messages.proto' (используя компилятор \verb'protoc') в файлы на C++ и Python, после чего перекомпилировать проекты \verb'libartm' и \verb'artm'.
\end{enumerate}

\paragraph{Рекомендации по написанию файлов регуляризаторов.} Любой регуляризатор, описанный в библиотеке, должен удовлетворять нескольким требованиям:

\begin{itemize}
	\item Регуляризатор обязательно пишется (как и всё ядро библиотеки) на С++ (.cс и .h файлы).

	\item Регуляризатор представляет собой класс-наследник класса \verb'RegularizerInterface'. Данный класс содержит два метода
	
	\vspace{10pt}
	\verb|bool RegularizeTheta(const Item& item,| 
	
	\verb|    std::vector<float>* n_dt, int topic_size, int inner_iter)|
	
	\verb'bool RegularizePhi(TopicModel* topic_model)'
	\vspace{10pt}
	
	Как понятно из названия, каждый метод отвечает за регуляризацию соответствующей матрицы.
	
	\item Класс регуляризатора вместе со всем своим содержимым должен быть описан в namespace \verb'regularizer'.
	
	\item Технически допустима реализация в одном классе регуляризатора сразу для обеих матриц, однако рекомендуется этого избегать и описывать один (в математическом смысле) регуляризатор в двух разных классах и работать с ними как с разными объектами. Это существенно упростит конфигурацию отдельного регуляризатора, использование его данных в функциях регуляризации, а также избавит от необходимости задавать ненужные данные, когда потребуется регуляризация только одной матрицы.
	
	\item Файл \verb'.h' будет отличаться для разных регуляризаторов только названием, достаточно скопировать какой-нибудь существующий (регуляризирующий ту же матрицу) и поменять необходимые имена типов.
	
	\item Файл \verb'.cc' будет включать в себя реализацию соответствующего метода регуляризации. Сама реализация, в свою очередь, состоит из трёх концептуальных этапов --- считывания данных из объекта-конфигурации, проверки корректности этих данных и собственно регуляризации. Считывание данных рекомендуется производить в структуры тех же типов, что и используемые в конфигурации --- т.е. описанные в файлах \verb'messages.pb.h' и \verb'messages.pb.cc' protobuf-типы. Во время проверки корректности ввода следует возвращать из функции \verb'false' в случае выявления несоответствия. Наконец, после окончания этапа регуляризации следует вернуть \verb'true'.
	
\end{itemize}

В целом, при написании нового регуляризатора рекомендуется опираться на существующие реализации, это может сэкономить немало времени.

\subsection{Регуляризатор сглаживания/разреживания}

$\quad\;\:$Базовым регуляризатором в BigARTM является т.н. регуляризатор сглаживания/разреживания. Он представляет собой модификацию сглаживающего регуляризатора Дирихле (встроенного в модель LDA). Несмотря на простоту, уже данный регуляризатор решает задачи, более сложные, чем регуляризатор Дирихле. Именно на основе этого регуляризатора будут строится все эксперименты в рамках данной работы, поэтому рассмотрим его поподробнее\footnote{Описание регуляризатора Дирихле можно найти в \cite{voron2013ptm}.}.

\paragraph{Теоретическое описание}\footnote{Подробное описание и лингвистические обоснования этого регуляризатора можно найти в \cite{voron_potap_14}}
Разделим множество тем $T$ на предметные $S$ и фоновые $B$. Зададим вектор-столбцы параметров таким образом, чтобы в обеих матрицах $\Phi$ и $\Theta$ темы из $S$ одинаково разреживались, а темы из $B$ --- сглаживались каждая собственным образом. Это приводит к тому, что 

\begin{enumerate}
	\item каждая тема из $S$ приобретает некоторое выраженное ядро терминов, отличающее её от остальных тем;
	\item каждая фоновая тема из $B$ сглаживается, причём различность параметров приводит к тому, что разные темы выполняют различные задачи (выделение стоп-слов, общей лексики коллекции и т.п.).
\end{enumerate}

\paragraph{Детали программной реализации}
Данный регуляризатор был реализован в соответствии с инструкцией из предыдущего подраздела. Регуляризатор был разделён на два: для $\Theta$ и для $\Phi$. Далее мы будем рассматривать их как два разных объекта: \verb'SmoothSparseTheta' и \verb'SmoothSparsePhi'. 

Конфигурационные protobuf-сообщения имеют следующий вид:

\vspace{5pt}
\noindent\verb|message SmoothSparseThetaConfig {| \\
\verb|    repeated double alpha_0 = 1;| \\
\verb|    repeated DoubleArray tilde_alpha = 2;| \\
\verb|}|

\noindent\verb|message SmoothSparsePhiConfig {| \\
\verb|    required int32 background_topics_count = 1;| \\
\verb|    required double beta_0 = 2;| \\
\verb|    required DoubleArray tilde_beta = 3;| \\
\verb|    repeated double background_beta_0 = 4;| \\
\verb|    repeated DoubleArray background_tilde_beta = 5;| \\
\verb|}|

Для регуляризации $\Theta$ требуется на каждую итерацию прохода по документу один набор параметров. Это набор состоит из вектора длиной с число тем, которые нужны выделить, и коэффициента при этом векторе. После поэлементного перемножения данный вектор должен содержать отрицательные числа для тем из $S$, и положительные --- для тем из $B$.

Регуляризатор для $\Phi$ требует в явном виде указать число фоновых тем (это нужно для проверки корректности параметров). \verb'tilde_beta' --- вектор длиной с текущее число терминов в матрице $\Phi$, предназначенный для разреживания тем из $S$. \verb'beta_0' --- коэффициент при нём. Последние два параметра имеют тот же смысл, только они предназначены для фоновых тем, по одному набору на каждую.  

{\bf Замечание:} Базового типа \verb'DoubleArray' в protocol buffers нет, это пользовательский тип, эквивалентный вещественному массиву.

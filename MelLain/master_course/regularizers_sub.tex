
Ключевым отличием BigARTM от других библиотек алгоритмов тематического моделирования является наличие регуляризаторов. Задача данного раздела --- описать API, предоставленный библиотекой для работы с существующими реализациями регуляризаторов, а также пояснить схему добавления новых.

\subsection{Кракое описание механизма регуляризации в BigARTM}
Поскольку части матрицы $\Theta$ вычисляются независимо на разных процессорах, регуляризация $\Theta$ производится в каждом процессоре на всех внутренних итерациях. Объектом регуляризации является столбец матрицы (т.е. документ). Управлять процессом регуляризации $\Theta$ можно только между внешними итерациями. С матрицей $\Phi$ ситуация иная. Регуляризация происходит в $Merger$, после того, как все процессоры на данной внешней итерации отработали, и новая матрица $\Phi$ сформирована. Регуляризация в логическом смысле опять работает со столбцом (т.е. с темой), но технически регуляризаторы вызываются для каждого элемента матрицы. При этом нормировочная константа, необходимая для выполнения М-шага \ref{learning} алгоритма, автоматически поправляется. $\Phi$ регуляризуется только на тех внешних итерациях, на которых это указал пользователь вызовом соответствующей функции (см. ниже). 

\subsection{Существующие регуляризаторов}

Все регуляризаторы описываются своими proto-сообщениями, содержащими необходимые данные и параметры. Конфигурационное сообщение для регуляризатора матрицы $\Theta$ должно содержать по одному набору параметров для каждой внутренней итерации. Сообщение для регуляризатора матрицы $\Phi$ наполняется одним набором параметров для одной внешней итерации. По истечении внешней итерации все конфигурации могут быть обновлены.

На данный момент в BigARTM реализовано по одному базовому регуляризатору для каждой из матриц $\Phi$ и $\Theta$, информация о которых приведена ниже:

\begin{tabular}[t]{|p{14em}|p{26em}|}
\hline
\vspace{2pt} \textbf{Имя регуляризатора} \vspace{4pt} &
\vspace{2pt} \textbf{protobuf-сообщение} \vspace{4pt} \\

\hline
\vspace{4pt}

Регуляризатор сглаживания/ разреживания для $\Theta$ & 
\vspace{4pt}

\verb|message SmoothSparseThetaConfig {|
\verb|  repeated double alpha_0 = 1;|
\verb|  repeated DoubleArray tilde_alpha = 2;|

\verb|}|
\vspace{4pt}

\\
\hline
\vspace{4pt}

Регуляризатор сглаживания/ разреживания для $\Phi$ &
\vspace{4pt}

\verb|message SmoothSparsePhiConfig {|
\verb|  required int32 background_topics_count = 1;|
\verb|  required double beta_0 = 2;|
\verb|  required DoubleArray tilde_beta = 3;|
\verb|  repeated double background_beta_0 = 4;|
\verb|  repeated DoubleArray background_tilde_beta = 5;|
\verb|}|
\vspace{4pt}

\\
\hline
\end{tabular}

\paragraph{Cмысл регуляризаторов сглаживания/разреживания и их параметров}

Регуляризатор сглаживания/разреживания
\footnote{Подробное описание и лингвистические обоснования этого регуляризатора можно найти в \cite{voron_potap_14}}
 представляет собой модификацию сглаживающего регуляризатора Дирихле (встроенного в модель LDA и описанного в разделе \ref{learning}). Несмотря на простоту, уже данный регуляризатор решает задачи более сложные, чем регуляризатор Дирихле.

Разделим множество тем $T$ на предметные $S$ и фоновые $B$. Зададим вектор-столбцы параметров таким образом, чтобы в обеих матрицах $\Phi$ и $\Theta$ темы из $S$ одинаково разреживались, а темы из $B$ --- сглаживались каждая собственным образом. Это приводит к тому, что 

\begin{itemize}
	\item каждая тема из $S$ приобретает некоторое выраженное ядро терминов, отличающее её от остальных тем;
	\item каждая фоновая тема из $B$ сглаживается, причём вариация параметров приводит к тому, что разные темы выполняют различные задачи (выделение стоп-слов, общей лексики коллекции и т.п.).
\end{itemize}

{\bf Замечание:} В данной реализации регуляризатора фоновыми считаются $|B|$ тем с конца.

Для регуляризатора $\Theta$ каждый набор параметров состоит из вектора длиной в число тем (\verb|tilde_alpha|) и коэффициента при этом векторе (\verb|alpha_0|). После поэлементного перемножения данный вектор должен содержать отрицательные числа для тем из $S$, и положительные --- для тем из $B$.

Регуляризатор для $\Phi$ требует в явном виде указать число фоновых тем (поле \verb|background_topics_count|) --- это нужно для проверки корректности параметров. \verb'tilde_beta' --- вектор длиной с текущее число терминов в матрице $\Phi$, предназначенный для разреживания тем из $S$. \verb'beta_0' --- коэффициент при нём. Последние два параметра имеют тот же смысл и предназначены для фоновых тем, по одному набору на каждую.  

\subsection{Подключение регуляризаторов}

Теперь, на примере \verb|SmoothSparseTheta|, будет рассмотрен поэтапно процесс включения регуляризатора в тематическую модель. Предполагается, что переменная \verb|topic_counts| содержит общее число тем, выделяемых данной моделью, а \verb|background_topics_count| --- число тем, объявленных фоновыми.

\begin{enumerate}
	\item Прежде всего следует описать конфигурационное сообщение для регуляризатора. Оно может быть описано так:
	
	\vspace{4pt}
        \verb|  regularizer_config_theta = messages_pb2.SmoothSparseThetaConfig()| \\
        \verb|  for i in range(0, inner_iterations_count):| \\
        \verb|    regularizer_config_theta.alpha_0.append(1)| \\
        \verb|    tilde_alpha_ref = regularizer_config_theta.tilde_alpha.add()| \\
        \verb|    for j in range(0, topics_count - background_topics_count):| \\
        \verb|      tilde_alpha_ref.value.append(-1)| \\
        \verb|    for j in range(0, background_topics_count):| \\
        \verb|      tilde_alpha_ref.value.append(1)|
	\vspace{4pt}
	
	\item Любой регуляризатор в BigARTM используется только в сообщении-оболочке \verb|Regularizer|, являющемся общим для всех регуляризаторов и имеющем вид: 
	
	\vspace{4pt}
        \verb|message RegularizerConfig {| \\
        \verb|  enum Type { ... }| \\
        
        \verb|  required string name = 1;| \\
        \verb|  required Type type = 2;| \\
        \verb|  required bytes config = 3;| \\
        \verb|}|
	\vspace{4pt}
	
	В данном сообщении первое поле --- имя добавляемого регуляризатора, второе --- тип (описанным выше регуляризаторам сглаживания/разреживания соответствуют типы 2 и 3), третье поле --- описанная выше конфигурация самого регулризатора, сериализованная функциями protocol buffers в массив байтов. В рассматриваемом примере возможно следующее определение этой оболочки:
	
	\vspace{4pt}
        \verb|  general_regularizer_config_theta = messages_pb2.RegularizerConfig()| \\
        \verb|  general_regularizer_config_theta.name = 'regularizer_theta'| \\
        \verb|  general_regularizer_config_theta.type = 2| \\
        \verb|  general_regularizer_config_theta.config = | \\
        \verb|    regularizer_config_theta.SerializeToString()|
	\vspace{4pt}	
	
	\item После описания сообщения-оболочки, можно создать объект регуляризатора:

	\vspace{4pt}	
	\verb|  regularizer_theta = master_component.CreateRegularizer(| \\
	\verb|    general_regularizer_config_theta)|
	\vspace{4pt}	
	
	Добавляемый регуляризатор сохранён в данном \verb|MasterComponent|, все модели, ассоциированные с этим \verb|MasterComponent|, могут использовать его.
	
	\item Теперь требуется сообщить нужной тематической модели о том, что при её обучении должен использоваться \verb|regularizer_theta|. Для этого требуется модификации шага \ref{step_1} в алгоритме работы с библиотекой. Перед созданием модели её конфигурация дополняется ещё одной строкой:
	
	\vspace{4pt}	
	\verb|  model_config.regularizer_name.append('regularizer_theta')|
	\vspace{4pt}	
		
	Таким образом модель <<узнаёт>> имя регуляризатора, который нужно будет использовать. Разные модели могут иметь разные списки используемых регуляризаторов. При этом все эти регуляризаторы, как уже было отмечено, будут храниться в активном экземпляре \verb|MasterComponent|.
	
	\item В случае, когда на данной внешней итерации нужно произвести регуляризацию $\Phi$, необходимо в шаге \ref{step_2} алгоритма использования библиотеки после строки
	
	\vspace{4pt}	
	\verb|  topic_model = master_component.GetTopicModel(model)|
	\vspace{4pt}	
	
	сразу вставить строку 
	
	\vspace{4pt}	
	\verb|  model.InvokePhiRegularizers();|
	\vspace{4pt}		
	
	Выгрузку модели нужно произвести раньше, поскольку её данные могут быть нужны для регуляризации. В случае, если данная внешняя итерация является последней, для учёта регуляризации требуется ещё раз выгрузить модель уже после вызова регуляризации и полученный результат считать финальным.
	
	Стоит обратить внимание на то, что при регуляризации будут вызваны все регуляризаторы матрицы $\Phi$, ассоциированные с данной моделью.
	
	\item Часто возникает потребность заменить параметры существующего регуляризатора. Для этого необходимо описать новое конфигурационное сообщение, которое, после сериализации, нужно присвоить полю \verb|config| в сообщении-обёртке \verb|general_regularizer_config_theta|. После этого вызывается функция перенастройки:
	
	\vspace{4pt}	
	\verb|  regularizer_theta.Reconfigure(general_regularizer_config_theta)|
	\vspace{4pt}	
	
	\item Для удаления регуляризатора из модели достаточно удалить его имя из списка \verb|model_config.regularizer_name| и реконфигурировать модель обновлённой \verb|model_config|. Сам \verb|regularizer| будет удалён автоматически при завершении работы \verb|MasterComponent|.
	
\end{enumerate}

\subsection{Создание нового регуляризатора}
\footnote{Данный раздел не имеет отношения к пользовательской документации и предназначен для разработчиков BigARTM. Описанная в нём информация требует более глубокого понимания устройства библиотеки}

Далее описан процесс создания нового регуляризатора и добавления его в библиотеку. Данные действия подчиняются некоторым общим правилам, поэтому будут изложены в алгоритмическом виде:

\begin{enumerate}
	\item В первую очередь требуется описать в файле \verb'messages.proto' protobuf-сообщение ---  конфигурацию нового регуляризатора, после чего добавить соответствующий элемент в поле \verb'Type' в сообщении-оболочке \verb'RegularizerConfig'.
	
	\item Затем необходимо написать \verb'.h' и \verb'.cc' файлы создаваемого регуляризатора и добавить их в проект \verb'libartm'. В данном пункте следует учитывать несколько деталей, которые будут рассмотрены подробнее в конце данного раздела.
	
	\item После нужно добавить в файл \verb'c_interface.cc #include' с именем \verb'.h' файла нового регуляризатора.
	
	\item В  \verb'c_interface.cc' надо найти функцию \verb'ArtmReconfigureRegularizer()'. В ней есть switch по типам регуляризаторов, в который требуется добавить case с типом своего регуляризатора (для этого можно просто скопировать один из существующих case и поменять в нём имена регуляризатора и его конфигурации).
	
	\item Для того, чтобы использовать добавленный регуляризатор, осталось скомпилировать \verb'messages.proto' (используя компилятор \verb'protoc') в файлы на C++ и Python, после чего перекомпилировать проекты \verb'libartm' и \verb'artm'.
\end{enumerate}

\paragraph{Рекомендации по написанию файлов регуляризаторов.} Любой регуляризатор, описанный в библиотеке, должен удовлетворять нескольким требованиям:

\begin{itemize}
	\item Регуляризатор обязательно пишется (как и всё ядро библиотеки) на С++ (.cс и .h файлы).

	\item Регуляризатор представляет собой класс-наследник класса \verb'RegularizerInterface'. Данный класс содержит два метода
	
	\vspace{10pt}
	\verb|bool RegularizeTheta(const Item& item,| 
	
	\verb|    std::vector<float>* n_dt, int topic_size, int inner_iter)|
	
	\verb'bool RegularizePhi(TopicModel* topic_model)'
	\vspace{10pt}
	
	Как понятно из названия, каждый метод отвечает за регуляризацию соответствующей матрицы.
	
	\item Класс регуляризатора вместе со всем своим содержимым должен быть описан в namespace \verb'regularizer'.
	
	\item Технически допустима реализация в одном классе регуляризатора сразу для обеих матриц, однако рекомендуется этого избегать и описывать один (в математическом смысле) регуляризатор в двух разных классах и работать с ними как с разными объектами. Это существенно упростит конфигурацию отдельного регуляризатора, использование его данных в функциях регуляризации, а также избавит от необходимости задавать ненужные данные, когда потребуется регуляризация только одной матрицы.
	
	\item Файл \verb'.h' будет отличаться для разных регуляризаторов только названием, достаточно скопировать какой-нибудь существующий (регуляризирующий ту же матрицу) и поменять необходимые имена типов.
	
	\item Файл \verb'.cc' будет включать в себя реализацию соответствующего метода регуляризации. Сама реализация, в свою очередь, состоит из трёх концептуальных этапов --- считывания данных из объекта-конфигурации, проверки корректности этих данных и собственно регуляризации. Считывание данных рекомендуется производить в структуры тех же типов, что и используемые в конфигурации --- т.е. описанные в файлах \verb'messages.pb.h' и \verb'messages.pb.cc' protobuf-типы. Во время проверки корректности ввода следует возвращать из функции \verb'false' в случае выявления несоответствия. Наконец, после окончания этапа регуляризации следует вернуть \verb'true'.
	
\end{itemize}

{\bf Замечание: } В целом, при написании нового регуляризатора рекомендуется опираться на существующие реализации, это может сэкономить немало времени.
